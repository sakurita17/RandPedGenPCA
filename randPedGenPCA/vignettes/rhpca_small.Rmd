---
title: "exercise-1-small-example"
output: html_document
---

```{r}
# This script requires the following R packages:
#
# install.packages(pkg = c("pedigreeTools", "Matrix", "randPedPCA", "ggplot2", "dplyr", "rvsd"))
```


```{r}
rm(list = ls())

#TODO: Add correction variation of not explain  version1 Ok
#TODO: Add correction variation of not explain  version 2 (Later)
#TODO: rgpca  
#TODO: Create github issues from picture
```

# Libraries

```{r setup, include=FALSE}
library(pedigreeTools)
library(Matrix)
library(randPedPCA)
library(ggplot2)
library(dplyr)
library(rsvd)
source("utils.R")
```

# Data description and preparation

Pedigree and genomic data from Mrode2023 (Chapter 11) - Linear models for the prediction of the genetic merit of animals 

## Pedigree


```{r}
# Pedigree
label <- 1:26
sire <- c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 13, 15, 15, 14, 14, 14, 1, 14, 14, 14, 14, 14)
dam <- c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 4, 2, 5, 6, 9, 9, 3, 8, 11, 10, 7, 12)
geno <- c(13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)
non_geno <- label[!(label %in% geno)]
```



```{r}
ped <- pedigree(
  sire  = sire,
  dam   = dam,
  label = label
)
```



## Additive numerator relationship matrix A

```{r}
A <- getA(ped)
L <- t(getL(ped)) 
Ainv <- getAInv(ped)
Li  <- getLInv(ped)
```


## Genomic relationship matrix G

```{r}

# Molecular maekers 
markers_df <- read.table(text = "
animal sire dam mean EDC fat_DYD SNP1 SNP2 SNP3 SNP4 SNP5 SNP6 SNP7 SNP8 SNP9 SNP10
13    0   0    1 558     9.0    2    0    1    1    0    0    0    2    1     2
14    0   0    1 722    13.4    1    0    0    0    0    2    0    2    1     0
15   13   4    1 300    12.7    1    1    2    1    1    0    0    2    1     2
16   15   2    1  73    15.4    0    0    2    1    0    1    0    2    2     1
17   15   5    1  52     5.9    0    1    1    2    0    0    0    2    1     2
18   14   6    1  87     7.7    1    1    0    1    0    2    0    2    2     1
19   14   9    1  64    10.2    0    0    1    1    0    2    0    2    2     0
20   14   9    1 103     4.8    0    1    1    0    0    1    0    2    2     0
21    1   3    1  13     7.6    2    0    0    0    0    1    2    2    1     2
22   14   8    1 125     8.8    0    0    0    1    1    2    0    2    0     0
23   14  11    1  93     9.8    0    1    1    0    0    1    0    2    2     1
24   14  10    1  66     9.2    1    0    0    0    1    1    0    2    0     0
25   14   7    1  75    11.5    0    0    0    1    1    2    0    2    1     0
26   14  12    1  33    13.3    1    0    1    1    0    2    0    1    0     0
", header = TRUE)
```


```{r}
M <- markers_df[, 7:16]
```


Using vanraden (2008) method 

$G=ZZ^T$. if I do Cholesky of G, I will have upper and lower triangular matrices, $Z$ and $Z^T$ respectively, what happen with the scalar factor???  



```{r}
getG <- function(M) {
  
  # Alles frequencies
  p = apply(M, 2, mean)/2
  q = 1 - p
  
  # Creating P matrix
  #P = matrix(rep(p*2, nrow(M)), ncol = ncol(M), nrow = nrow(M), byrow = TRUE)
  
  # Z = M - P
  #Z <- as.matrix(M - P)
  Z <- sweep(x = as.matrix(M), MARGIN = 2, STATS = 2*p, FUN = "-")
  
  # scaled factor k = 2*sum*(p*q)
  k <- 2*sum(p*q)
  
  # G matrix
  G <- (Z%*%t(Z))/k # TODO crossprod()
  #
  return(G)
} 
```


```{r}
G <- getG(M)
diag(G) <- diag(G) + 0.01
```


# Direct method, explicit "x" multiplication Hx
Cholesky decomposition of $H = SS^T$

```{r}
# H matrix
A11 <- A[non_geno, non_geno]
A22 <- A[geno, geno]
A12 <- A[non_geno, geno]
A21 <- t(A12)

## H components (4 quadrants), using linear solves instead of explicit inverses
# Precompute useful solves
B <- solve(A22, A21)          # = A_22^{-1} A_21
D <- solve(A22, G - A22)      # = A_22^{-1} (G - A_22)

H11 <- A11 + A12 %*% D %*% B
H12 <- A12 %*% solve(A22, G)
H21 <- t(H12)
H22 <- G

## Bind blocks (cBind/rBind are defunct; use base cbind/rbind)
Htop    <- cbind(H11, H12)
Hbottom <- cbind(H21, H22)
H        <- rbind(Htop, Hbottom)

# reorder H
# temporary object if i need to repeeat a task
H <- H[order(as.numeric(rownames(H))), order(as.numeric(colnames(H)))]

# convert to Matrix
H <- Matrix(H)

rownames(H) <- 1:26
colnames(H) <- 1:26

#S <- t(chol(H)) # I can not run cholesky of H because itis not positive defined, I got error, make sense to do svd(Z), it was solved because we corrected by allele frecuencies.. etc 
H
```


# Indirect magic method, implicit "omega" multiplication H*omega

## Step 1: Z = AX

```{r}
set.seed(42)
n <- nrow(Li)
numVectors <- 1
testVectors <- rnorm(n = n * numVectors)
testMatrix <- matrix(testVectors, nrow = n, ncol = numVectors)

Ax_direct <- A %*% testMatrix
Hx_direct <- H %*% testMatrix

Z  <- oraculumLi(Li, testMatrix)
Z1 <- Z[non_geno, seq_len(numVectors), drop = FALSE]
Z2 <- Z[geno, seq_len(numVectors), drop = FALSE]

plot(Z, Ax_direct)
```




## Step 2

Note: Upper x lower = inverse

### 2.1) $R = A^{12}Z_2$


```{r}
# ----- R_direct
Ainv12 <- Ainv[non_geno, geno]
R_direct <- Ainv12 %*% Z2

# ----- R_indirect
subMatrix <- testMatrix * 0
subMatrix[geno, ] <- as.matrix(Z2)
R_indirect <- crossprod(Li, Li %*% subMatrix)
R_indirect <- R_indirect[non_geno, , drop=FALSE]

plot(R_direct, R_indirect)

```


### 2.2) $M = A^{22}Z_2$

```{r}
# ----- M_direct
Ainv22 <- Ainv[geno, geno]
M_direct <- Ainv22 %*% Z2

# ----- M_indirect
subMatrix <- testMatrix * 0
subMatrix[geno, ] <- as.matrix(Z2)
M_indirect <- crossprod(Li, Li %*% subMatrix)
M_indirect <- M_indirect[geno, , drop=FALSE]

plot(M_direct, M_indirect)
```


### 2.3) $Q = (A^{11})^{-1}, R)$

Ainv = t(Li) %*% Li

```{r}
# ----- Q_direct
Ainv11   <- Ainv[non_geno, non_geno, drop=FALSE]  # A^{11}
Q_direct <- solve(Ainv11, R_indirect) # CM method from Stranden et al. (2016)

# solve(Ainv11) %*% r_indirect - q_direct # test


# ----- Q_indirect
# See methods IOP and IM in Stranden et al. (2016) https://pubmed.ncbi.nlm.nih.gov/28508482/
Q_indirect <- Q_direct
```


### 2.4) $P = -A^{21}Q$

```{r}
# ----- P_direct
Ainv21 <- Ainv[geno, non_geno]
P_direct <- -(Ainv21 %*% Q_direct)

# ----- P_indirect
subMatrix <- testMatrix * 0
subMatrix[non_geno, ] <- as.matrix(Q_indirect)
P_indirect <- crossprod(Li, Li %*% subMatrix)
P_indirect <- -(P_indirect[geno, , drop=FALSE])

plot(P_direct, P_indirect)
```

### 2.5) $f(Z_2) = P + M$

```{r}
f_Z2 <- P_indirect + M_indirect
```


### 2.6) $Y_{2} = ZZ^{T}f(Z_2)/k$

```{r}
p <- apply(M, 2, mean)/2
q <- 1 - p
Z <- sweep(x = as.matrix(M), MARGIN = 2, STATS = 2*p, FUN = "-")
k <- 2*sum(p*q)
G <- (Z%*%t(Z))/k 
diag(G) <- diag(G) + 0.01


# ----- y2_direct
Y2_direct <- G %*% testMatrix[geno, ]

# ----- y2_indirect
C  <- crossprod(Z, f_Z2)
Y2 <- Z %*% C

eps <- 0.01
E <- testMatrix[geno, ] * eps 

Y2_indirect <- (Y2/k) + E

plot(Y2_indirect, Hx_direct[geno,])
```

## Step 3

```{r}
D2 <- Y2_indirect - Z2
```


## Step 4

### 4.1) $R = A^{12}D_2$

```{r}
# ----- R_direct
Ainv12 <- Ainv[non_geno, geno]
R_direct <- Ainv12 %*% D2

# ----- R_indirect
subMatrix <- testMatrix * 0
subMatrix[geno, ] <- as.matrix(D2)
R_indirect <- crossprod(Li, Li %*% subMatrix)
R_indirect <- R_indirect[non_geno, , drop=FALSE]

plot(R_direct[, 1], R_indirect[, 1])
```

### 4.2) $M = A^{22}D_2$

```{r}
# ----- M_direct
Ainv22 <- Ainv[geno, geno]
M_direct <- Ainv22 %*% D2

# ----- M_indirect
subMatrix <- testMatrix * 0
subMatrix[geno, ] <- as.matrix(D2)
M_indirect <- crossprod(Li, Li %*% subMatrix)
M_indirect <- M_indirect[geno, , drop=FALSE]

plot(M_direct[,1], M_indirect[,1]) 

```

### 4.3) $Q = (A^{11})^{-1}, R)$

```{r}
# ----- Q_direct
Ainv11   <- Ainv[non_geno, non_geno, drop=FALSE]  # A^{11}
Q_direct <- solve(Ainv11, R_indirect) # CM method from Stranden et al. (2016)

# solve(Ainv11) %*% r_indirect - q_direct # test

# ----- Q_indirect
# See methods IOP and IM in Stranden et al. (2016) https://pubmed.ncbi.nlm.nih.gov/28508482/
Q_indirect <- Q_direct

```


### 4.4) $P = -A^{21}Q$

```{r}
# ----- P_direct
Ainv21 <- Ainv[geno, non_geno]
P_direct <- -(Ainv21 %*% Q_direct)

# ----- P_indirect
subMatrix <- testMatrix * 0
subMatrix[non_geno, ] <- as.matrix(Q_indirect)
P_indirect <- crossprod(Li, Li %*% subMatrix)
P_indirect <- -(P_indirect[geno, , drop=FALSE])

plot(P_direct[,1], P_indirect[,1]) 

```


### 4.5) $f(D_2) = P + M$

```{r}
f_D2 <- P_indirect + M_indirect
```


### 4.6) $D_{1} = A_{12}f(D_1)$

```{r}
# ----- D1_direct
A12 <- A[non_geno, geno, drop = FALSE]
D1_direct <- A12 %*% f_D2

# ----- D1_indirect
subMatrix <- testMatrix * 0
subMatrix[geno, ] <- as.matrix(f_D2)
D1_indirect  <- oraculumLi(Li, subMatrix)
D1_indirect <- D1_indirect[non_geno, , drop = FALSE]
 
plot(D1_direct[ ,1], D1_indirect[ ,1])
```

## Step 5

```{r}
Y1_indirect <- Z1 + D1_indirect
plot(Y1_indirect, Hx_direct[non_geno,])
```

## Step 6 

```{r}
Hx_indirect_magic <- matrix(0,
                            nrow = n, 
                            ncol = numVectors) 
Hx_indirect_magic[non_geno, ] <- as.matrix(Y1_indirect)
Hx_indirect_magic[geno, ] <- as.matrix(Y2_indirect)
```





# Function

```{r}
Hx_magic <- oraculumH(Li, M, non_geno = non_geno, geno = geno, testMatrix, eps = 0.01)
```


```{r}
Hx_magic_pca <- rhpca(Li, M, non_geno, geno, rank = 3, depth = 3, numVectors = 3, eps = 0.01)
```

```{r}
par(mfrow = c(1,1))
par(oma = rep(0,4))
par(mar = c(3,3,2,1))
plot(H_pca$vectors[,1], Hx_magic_pca$u[,1])
```


